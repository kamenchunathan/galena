// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::non_canonical_partial_ord_impl)]


use roc_std::RocRefcounted;
use roc_std::roc_refcounted_noop_impl;

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct InternalAttr_Attribute {
    pub f0: roc_std::RocStr,
    pub f1: roc_std::RocStr,
}

impl roc_std::RocRefcounted for InternalAttr_Attribute {
    fn inc(&mut self) {
         self.f0.inc();
     self.f1.inc();

    }
    fn dec(&mut self) {
         self.f0.dec();
     self.f1.dec();

    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct R2 {
    pub id: roc_std::RocStr,
    pub tagName: roc_std::RocStr,
    pub value: roc_std::RocStr,
    pub checked: bool,
}

impl roc_std::RocRefcounted for R2 {
    fn inc(&mut self) {
         self.id.inc();
     self.tagName.inc();
     self.value.inc();

    }
    fn dec(&mut self) {
         self.id.dec();
     self.tagName.dec();
     self.value.dec();

    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct InternalEvent {
    pub button: i32,
    pub clientX: i32,
    pub clientY: i32,
    pub code: roc_std::RocStr,
    pub currentTarget: R2,
    pub eventType: roc_std::RocStr,
    pub key: roc_std::RocStr,
    pub target: R2,
    pub altKey: bool,
    pub ctrlKey: bool,
    pub metaKey: bool,
    pub preventDefault: bool,
    pub shiftKey: bool,
    pub stopPropagation: bool,
}

impl roc_std::RocRefcounted for InternalEvent {
    fn inc(&mut self) {
         self.code.inc();
     self.currentTarget.inc();
     self.eventType.inc();
     self.key.inc();
     self.target.inc();

    }
    fn dec(&mut self) {
         self.code.dec();
     self.currentTarget.dec();
     self.eventType.dec();
     self.key.dec();
     self.target.dec();

    }
    fn is_refcounted() -> bool {
        true
    }
}



#[repr(C)]
#[derive(Debug)]
pub struct RocFunction_3546 {
    closure_data: Vec<u8>,
}

impl RocFunction_3546 {
    pub fn force_thunk(mut self, arg0: InternalEvent) -> u32 {
        extern "C" {
            fn roc__main_for_host_0_caller(arg0: *const InternalEvent, closure_data: *mut u8, output: *mut u32);
        }

        let mut output = core::mem::MaybeUninit::uninit();

        unsafe {
            roc__main_for_host_0_caller(&arg0, self.closure_data.as_mut_ptr(), output.as_mut_ptr());

            output.assume_init()
        }
    }
}roc_refcounted_noop_impl!(RocFunction_3546);

#[derive(Clone, Debug, )]
#[repr(C)]
pub struct InternalAttr_OnEvent {
    pub f0: roc_std::RocStr,
    pub f1: RocFunction_3546,
}

impl roc_std::RocRefcounted for InternalAttr_OnEvent {
    fn inc(&mut self) {
         self.f0.inc();

    }
    fn dec(&mut self) {
         self.f0.dec();

    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_InternalAttr {
    Alt = 0,
    Attribute = 1,
    Autocomplete = 2,
    Checked = 3,
    Class = 4,
    DataAttribute = 5,
    Disabled = 6,
    Hidden = 7,
    Href = 8,
    Id = 9,
    Multiple = 10,
    Name = 11,
    OnEvent = 12,
    Placeholder = 13,
    Readonly = 14,
    Required = 15,
    Selected = 16,
    Src = 17,
    Style = 18,
    Tabindex = 19,
    Title = 20,
    Type = 21,
    Value = 22,
}

impl core::fmt::Debug for discriminant_InternalAttr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Alt => f.write_str("discriminant_InternalAttr::Alt"),
            Self::Attribute => f.write_str("discriminant_InternalAttr::Attribute"),
            Self::Autocomplete => f.write_str("discriminant_InternalAttr::Autocomplete"),
            Self::Checked => f.write_str("discriminant_InternalAttr::Checked"),
            Self::Class => f.write_str("discriminant_InternalAttr::Class"),
            Self::DataAttribute => f.write_str("discriminant_InternalAttr::DataAttribute"),
            Self::Disabled => f.write_str("discriminant_InternalAttr::Disabled"),
            Self::Hidden => f.write_str("discriminant_InternalAttr::Hidden"),
            Self::Href => f.write_str("discriminant_InternalAttr::Href"),
            Self::Id => f.write_str("discriminant_InternalAttr::Id"),
            Self::Multiple => f.write_str("discriminant_InternalAttr::Multiple"),
            Self::Name => f.write_str("discriminant_InternalAttr::Name"),
            Self::OnEvent => f.write_str("discriminant_InternalAttr::OnEvent"),
            Self::Placeholder => f.write_str("discriminant_InternalAttr::Placeholder"),
            Self::Readonly => f.write_str("discriminant_InternalAttr::Readonly"),
            Self::Required => f.write_str("discriminant_InternalAttr::Required"),
            Self::Selected => f.write_str("discriminant_InternalAttr::Selected"),
            Self::Src => f.write_str("discriminant_InternalAttr::Src"),
            Self::Style => f.write_str("discriminant_InternalAttr::Style"),
            Self::Tabindex => f.write_str("discriminant_InternalAttr::Tabindex"),
            Self::Title => f.write_str("discriminant_InternalAttr::Title"),
            Self::Type => f.write_str("discriminant_InternalAttr::Type"),
            Self::Value => f.write_str("discriminant_InternalAttr::Value"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_InternalAttr);

#[repr(C, align(4))]
pub union union_InternalAttr {
    Alt: core::mem::ManuallyDrop<roc_std::RocStr>,
    Attribute: core::mem::ManuallyDrop<InternalAttr_Attribute>,
    Autocomplete: core::mem::ManuallyDrop<roc_std::RocStr>,
    Checked: bool,
    Class: core::mem::ManuallyDrop<roc_std::RocStr>,
    DataAttribute: core::mem::ManuallyDrop<InternalAttr_Attribute>,
    Disabled: bool,
    Hidden: bool,
    Href: core::mem::ManuallyDrop<roc_std::RocStr>,
    Id: core::mem::ManuallyDrop<roc_std::RocStr>,
    Multiple: bool,
    Name: core::mem::ManuallyDrop<roc_std::RocStr>,
    OnEvent: core::mem::ManuallyDrop<InternalAttr_OnEvent>,
    Placeholder: core::mem::ManuallyDrop<roc_std::RocStr>,
    Readonly: bool,
    Required: bool,
    Selected: bool,
    Src: core::mem::ManuallyDrop<roc_std::RocStr>,
    Style: core::mem::ManuallyDrop<roc_std::RocStr>,
    Tabindex: i32,
    Title: core::mem::ManuallyDrop<roc_std::RocStr>,
    Type: core::mem::ManuallyDrop<roc_std::RocStr>,
    Value: core::mem::ManuallyDrop<roc_std::RocStr>,
}

// TODO(@roc-lang): See https://github.com/roc-lang/roc/issues/6012
// const _SIZE_CHECK_union_InternalAttr: () = assert!(core::mem::size_of::<union_InternalAttr>() == 28);
const _ALIGN_CHECK_union_InternalAttr: () = assert!(core::mem::align_of::<union_InternalAttr>() == 4);

const _SIZE_CHECK_InternalAttr: () = assert!(core::mem::size_of::<InternalAttr>() == 28);
const _ALIGN_CHECK_InternalAttr: () = assert!(core::mem::align_of::<InternalAttr>() == 4);

impl InternalAttr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_InternalAttr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_InternalAttr>(*bytes.as_ptr().add(24))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_InternalAttr) {
        let discriminant_ptr: *mut discriminant_InternalAttr = (self as *mut InternalAttr).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct InternalAttr {
    payload: union_InternalAttr,
    discriminant: discriminant_InternalAttr,
}

impl Clone for InternalAttr {
    fn clone(&self) -> Self {
        use discriminant_InternalAttr::*;

        let payload = unsafe {
            match self.discriminant {
                Alt => union_InternalAttr {
                    Alt: self.payload.Alt.clone(),
                },
                Attribute => union_InternalAttr {
                    Attribute: self.payload.Attribute.clone(),
                },
                Autocomplete => union_InternalAttr {
                    Autocomplete: self.payload.Autocomplete.clone(),
                },
                Checked => union_InternalAttr {
                    Checked: self.payload.Checked.clone(),
                },
                Class => union_InternalAttr {
                    Class: self.payload.Class.clone(),
                },
                DataAttribute => union_InternalAttr {
                    DataAttribute: self.payload.DataAttribute.clone(),
                },
                Disabled => union_InternalAttr {
                    Disabled: self.payload.Disabled.clone(),
                },
                Hidden => union_InternalAttr {
                    Hidden: self.payload.Hidden.clone(),
                },
                Href => union_InternalAttr {
                    Href: self.payload.Href.clone(),
                },
                Id => union_InternalAttr {
                    Id: self.payload.Id.clone(),
                },
                Multiple => union_InternalAttr {
                    Multiple: self.payload.Multiple.clone(),
                },
                Name => union_InternalAttr {
                    Name: self.payload.Name.clone(),
                },
                OnEvent => union_InternalAttr {
                    OnEvent: self.payload.OnEvent.clone(),
                },
                Placeholder => union_InternalAttr {
                    Placeholder: self.payload.Placeholder.clone(),
                },
                Readonly => union_InternalAttr {
                    Readonly: self.payload.Readonly.clone(),
                },
                Required => union_InternalAttr {
                    Required: self.payload.Required.clone(),
                },
                Selected => union_InternalAttr {
                    Selected: self.payload.Selected.clone(),
                },
                Src => union_InternalAttr {
                    Src: self.payload.Src.clone(),
                },
                Style => union_InternalAttr {
                    Style: self.payload.Style.clone(),
                },
                Tabindex => union_InternalAttr {
                    Tabindex: self.payload.Tabindex.clone(),
                },
                Title => union_InternalAttr {
                    Title: self.payload.Title.clone(),
                },
                Type => union_InternalAttr {
                    Type: self.payload.Type.clone(),
                },
                Value => union_InternalAttr {
                    Value: self.payload.Value.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for InternalAttr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_InternalAttr::*;

        unsafe {
            match self.discriminant {
                Alt => {
                    let field: &roc_std::RocStr = &self.payload.Alt;
                    f.debug_tuple("InternalAttr::Alt").field(field).finish()
                },
                Attribute => {
                    let field: &InternalAttr_Attribute = &self.payload.Attribute;
                    f.debug_tuple("InternalAttr::Attribute").field(field).finish()
                },
                Autocomplete => {
                    let field: &roc_std::RocStr = &self.payload.Autocomplete;
                    f.debug_tuple("InternalAttr::Autocomplete").field(field).finish()
                },
                Checked => {
                    let field: &bool = &self.payload.Checked;
                    f.debug_tuple("InternalAttr::Checked").field(field).finish()
                },
                Class => {
                    let field: &roc_std::RocStr = &self.payload.Class;
                    f.debug_tuple("InternalAttr::Class").field(field).finish()
                },
                DataAttribute => {
                    let field: &InternalAttr_Attribute = &self.payload.DataAttribute;
                    f.debug_tuple("InternalAttr::DataAttribute").field(field).finish()
                },
                Disabled => {
                    let field: &bool = &self.payload.Disabled;
                    f.debug_tuple("InternalAttr::Disabled").field(field).finish()
                },
                Hidden => {
                    let field: &bool = &self.payload.Hidden;
                    f.debug_tuple("InternalAttr::Hidden").field(field).finish()
                },
                Href => {
                    let field: &roc_std::RocStr = &self.payload.Href;
                    f.debug_tuple("InternalAttr::Href").field(field).finish()
                },
                Id => {
                    let field: &roc_std::RocStr = &self.payload.Id;
                    f.debug_tuple("InternalAttr::Id").field(field).finish()
                },
                Multiple => {
                    let field: &bool = &self.payload.Multiple;
                    f.debug_tuple("InternalAttr::Multiple").field(field).finish()
                },
                Name => {
                    let field: &roc_std::RocStr = &self.payload.Name;
                    f.debug_tuple("InternalAttr::Name").field(field).finish()
                },
                OnEvent => {
                    let field: &InternalAttr_OnEvent = &self.payload.OnEvent;
                    f.debug_tuple("InternalAttr::OnEvent").field(field).finish()
                },
                Placeholder => {
                    let field: &roc_std::RocStr = &self.payload.Placeholder;
                    f.debug_tuple("InternalAttr::Placeholder").field(field).finish()
                },
                Readonly => {
                    let field: &bool = &self.payload.Readonly;
                    f.debug_tuple("InternalAttr::Readonly").field(field).finish()
                },
                Required => {
                    let field: &bool = &self.payload.Required;
                    f.debug_tuple("InternalAttr::Required").field(field).finish()
                },
                Selected => {
                    let field: &bool = &self.payload.Selected;
                    f.debug_tuple("InternalAttr::Selected").field(field).finish()
                },
                Src => {
                    let field: &roc_std::RocStr = &self.payload.Src;
                    f.debug_tuple("InternalAttr::Src").field(field).finish()
                },
                Style => {
                    let field: &roc_std::RocStr = &self.payload.Style;
                    f.debug_tuple("InternalAttr::Style").field(field).finish()
                },
                Tabindex => {
                    let field: &i32 = &self.payload.Tabindex;
                    f.debug_tuple("InternalAttr::Tabindex").field(field).finish()
                },
                Title => {
                    let field: &roc_std::RocStr = &self.payload.Title;
                    f.debug_tuple("InternalAttr::Title").field(field).finish()
                },
                Type => {
                    let field: &roc_std::RocStr = &self.payload.Type;
                    f.debug_tuple("InternalAttr::Type").field(field).finish()
                },
                Value => {
                    let field: &roc_std::RocStr = &self.payload.Value;
                    f.debug_tuple("InternalAttr::Value").field(field).finish()
                },
            }
        }
    }
}

impl InternalAttr {

    pub fn unwrap_Alt(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Alt);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Alt) }
    }

    pub fn borrow_Alt(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Alt);
        use core::borrow::Borrow;
unsafe { self.payload.Alt.borrow() }
    }

    pub fn borrow_mut_Alt(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Alt);
        use core::borrow::BorrowMut;
unsafe { self.payload.Alt.borrow_mut() }
    }

    pub fn is_Alt(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Alt)
    }

    pub fn unwrap_Attribute(mut self) -> InternalAttr_Attribute {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Attribute);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Attribute) }
    }

    pub fn borrow_Attribute(&self) -> &InternalAttr_Attribute {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Attribute);
        use core::borrow::Borrow;
unsafe { self.payload.Attribute.borrow() }
    }

    pub fn borrow_mut_Attribute(&mut self) -> &mut InternalAttr_Attribute {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Attribute);
        use core::borrow::BorrowMut;
unsafe { self.payload.Attribute.borrow_mut() }
    }

    pub fn is_Attribute(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Attribute)
    }

    pub fn unwrap_Autocomplete(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Autocomplete);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Autocomplete) }
    }

    pub fn borrow_Autocomplete(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Autocomplete);
        use core::borrow::Borrow;
unsafe { self.payload.Autocomplete.borrow() }
    }

    pub fn borrow_mut_Autocomplete(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Autocomplete);
        use core::borrow::BorrowMut;
unsafe { self.payload.Autocomplete.borrow_mut() }
    }

    pub fn is_Autocomplete(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Autocomplete)
    }

    pub fn unwrap_Checked(mut self) -> bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Checked);
        unsafe { self.payload.Checked }
    }

    pub fn borrow_Checked(&self) -> bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Checked);
        unsafe { self.payload.Checked }
    }

    pub fn borrow_mut_Checked(&mut self) -> &mut bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Checked);
        unsafe { &mut self.payload.Checked }
    }

    pub fn is_Checked(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Checked)
    }

    pub fn unwrap_Class(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Class);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Class) }
    }

    pub fn borrow_Class(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Class);
        use core::borrow::Borrow;
unsafe { self.payload.Class.borrow() }
    }

    pub fn borrow_mut_Class(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Class);
        use core::borrow::BorrowMut;
unsafe { self.payload.Class.borrow_mut() }
    }

    pub fn is_Class(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Class)
    }

    pub fn unwrap_DataAttribute(mut self) -> InternalAttr_Attribute {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::DataAttribute);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.DataAttribute) }
    }

    pub fn borrow_DataAttribute(&self) -> &InternalAttr_Attribute {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::DataAttribute);
        use core::borrow::Borrow;
unsafe { self.payload.DataAttribute.borrow() }
    }

    pub fn borrow_mut_DataAttribute(&mut self) -> &mut InternalAttr_Attribute {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::DataAttribute);
        use core::borrow::BorrowMut;
unsafe { self.payload.DataAttribute.borrow_mut() }
    }

    pub fn is_DataAttribute(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::DataAttribute)
    }

    pub fn unwrap_Disabled(mut self) -> bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Disabled);
        unsafe { self.payload.Disabled }
    }

    pub fn borrow_Disabled(&self) -> bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Disabled);
        unsafe { self.payload.Disabled }
    }

    pub fn borrow_mut_Disabled(&mut self) -> &mut bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Disabled);
        unsafe { &mut self.payload.Disabled }
    }

    pub fn is_Disabled(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Disabled)
    }

    pub fn unwrap_Hidden(mut self) -> bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Hidden);
        unsafe { self.payload.Hidden }
    }

    pub fn borrow_Hidden(&self) -> bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Hidden);
        unsafe { self.payload.Hidden }
    }

    pub fn borrow_mut_Hidden(&mut self) -> &mut bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Hidden);
        unsafe { &mut self.payload.Hidden }
    }

    pub fn is_Hidden(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Hidden)
    }

    pub fn unwrap_Href(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Href);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Href) }
    }

    pub fn borrow_Href(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Href);
        use core::borrow::Borrow;
unsafe { self.payload.Href.borrow() }
    }

    pub fn borrow_mut_Href(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Href);
        use core::borrow::BorrowMut;
unsafe { self.payload.Href.borrow_mut() }
    }

    pub fn is_Href(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Href)
    }

    pub fn unwrap_Id(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Id);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Id) }
    }

    pub fn borrow_Id(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Id);
        use core::borrow::Borrow;
unsafe { self.payload.Id.borrow() }
    }

    pub fn borrow_mut_Id(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Id);
        use core::borrow::BorrowMut;
unsafe { self.payload.Id.borrow_mut() }
    }

    pub fn is_Id(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Id)
    }

    pub fn unwrap_Multiple(mut self) -> bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Multiple);
        unsafe { self.payload.Multiple }
    }

    pub fn borrow_Multiple(&self) -> bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Multiple);
        unsafe { self.payload.Multiple }
    }

    pub fn borrow_mut_Multiple(&mut self) -> &mut bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Multiple);
        unsafe { &mut self.payload.Multiple }
    }

    pub fn is_Multiple(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Multiple)
    }

    pub fn unwrap_Name(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Name);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Name) }
    }

    pub fn borrow_Name(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Name);
        use core::borrow::Borrow;
unsafe { self.payload.Name.borrow() }
    }

    pub fn borrow_mut_Name(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Name);
        use core::borrow::BorrowMut;
unsafe { self.payload.Name.borrow_mut() }
    }

    pub fn is_Name(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Name)
    }

    pub fn unwrap_OnEvent(mut self) -> InternalAttr_OnEvent {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::OnEvent);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.OnEvent) }
    }

    pub fn borrow_OnEvent(&self) -> &InternalAttr_OnEvent {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::OnEvent);
        use core::borrow::Borrow;
unsafe { self.payload.OnEvent.borrow() }
    }

    pub fn borrow_mut_OnEvent(&mut self) -> &mut InternalAttr_OnEvent {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::OnEvent);
        use core::borrow::BorrowMut;
unsafe { self.payload.OnEvent.borrow_mut() }
    }

    pub fn is_OnEvent(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::OnEvent)
    }

    pub fn unwrap_Placeholder(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Placeholder);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Placeholder) }
    }

    pub fn borrow_Placeholder(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Placeholder);
        use core::borrow::Borrow;
unsafe { self.payload.Placeholder.borrow() }
    }

    pub fn borrow_mut_Placeholder(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Placeholder);
        use core::borrow::BorrowMut;
unsafe { self.payload.Placeholder.borrow_mut() }
    }

    pub fn is_Placeholder(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Placeholder)
    }

    pub fn unwrap_Readonly(mut self) -> bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Readonly);
        unsafe { self.payload.Readonly }
    }

    pub fn borrow_Readonly(&self) -> bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Readonly);
        unsafe { self.payload.Readonly }
    }

    pub fn borrow_mut_Readonly(&mut self) -> &mut bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Readonly);
        unsafe { &mut self.payload.Readonly }
    }

    pub fn is_Readonly(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Readonly)
    }

    pub fn unwrap_Required(mut self) -> bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Required);
        unsafe { self.payload.Required }
    }

    pub fn borrow_Required(&self) -> bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Required);
        unsafe { self.payload.Required }
    }

    pub fn borrow_mut_Required(&mut self) -> &mut bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Required);
        unsafe { &mut self.payload.Required }
    }

    pub fn is_Required(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Required)
    }

    pub fn unwrap_Selected(mut self) -> bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Selected);
        unsafe { self.payload.Selected }
    }

    pub fn borrow_Selected(&self) -> bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Selected);
        unsafe { self.payload.Selected }
    }

    pub fn borrow_mut_Selected(&mut self) -> &mut bool {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Selected);
        unsafe { &mut self.payload.Selected }
    }

    pub fn is_Selected(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Selected)
    }

    pub fn unwrap_Src(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Src);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Src) }
    }

    pub fn borrow_Src(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Src);
        use core::borrow::Borrow;
unsafe { self.payload.Src.borrow() }
    }

    pub fn borrow_mut_Src(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Src);
        use core::borrow::BorrowMut;
unsafe { self.payload.Src.borrow_mut() }
    }

    pub fn is_Src(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Src)
    }

    pub fn unwrap_Style(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Style);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Style) }
    }

    pub fn borrow_Style(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Style);
        use core::borrow::Borrow;
unsafe { self.payload.Style.borrow() }
    }

    pub fn borrow_mut_Style(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Style);
        use core::borrow::BorrowMut;
unsafe { self.payload.Style.borrow_mut() }
    }

    pub fn is_Style(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Style)
    }

    pub fn unwrap_Tabindex(mut self) -> i32 {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Tabindex);
        unsafe { self.payload.Tabindex }
    }

    pub fn borrow_Tabindex(&self) -> i32 {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Tabindex);
        unsafe { self.payload.Tabindex }
    }

    pub fn borrow_mut_Tabindex(&mut self) -> &mut i32 {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Tabindex);
        unsafe { &mut self.payload.Tabindex }
    }

    pub fn is_Tabindex(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Tabindex)
    }

    pub fn unwrap_Title(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Title);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Title) }
    }

    pub fn borrow_Title(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Title);
        use core::borrow::Borrow;
unsafe { self.payload.Title.borrow() }
    }

    pub fn borrow_mut_Title(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Title);
        use core::borrow::BorrowMut;
unsafe { self.payload.Title.borrow_mut() }
    }

    pub fn is_Title(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Title)
    }

    pub fn unwrap_Type(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Type);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Type) }
    }

    pub fn borrow_Type(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Type);
        use core::borrow::Borrow;
unsafe { self.payload.Type.borrow() }
    }

    pub fn borrow_mut_Type(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Type);
        use core::borrow::BorrowMut;
unsafe { self.payload.Type.borrow_mut() }
    }

    pub fn is_Type(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Type)
    }

    pub fn unwrap_Value(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Value);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.Value) }
    }

    pub fn borrow_Value(&self) -> &roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Value);
        use core::borrow::Borrow;
unsafe { self.payload.Value.borrow() }
    }

    pub fn borrow_mut_Value(&mut self) -> &mut roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalAttr::Value);
        use core::borrow::BorrowMut;
unsafe { self.payload.Value.borrow_mut() }
    }

    pub fn is_Value(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalAttr::Value)
    }
}



impl InternalAttr {

    pub fn Alt(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Alt,
            payload: union_InternalAttr {
                Alt: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Attribute(payload: InternalAttr_Attribute) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Attribute,
            payload: union_InternalAttr {
                Attribute: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Autocomplete(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Autocomplete,
            payload: union_InternalAttr {
                Autocomplete: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Checked(payload: bool) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Checked,
            payload: union_InternalAttr {
                Checked: payload,
            }
        }
    }

    pub fn Class(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Class,
            payload: union_InternalAttr {
                Class: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn DataAttribute(payload: InternalAttr_Attribute) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::DataAttribute,
            payload: union_InternalAttr {
                DataAttribute: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Disabled(payload: bool) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Disabled,
            payload: union_InternalAttr {
                Disabled: payload,
            }
        }
    }

    pub fn Hidden(payload: bool) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Hidden,
            payload: union_InternalAttr {
                Hidden: payload,
            }
        }
    }

    pub fn Href(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Href,
            payload: union_InternalAttr {
                Href: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Id(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Id,
            payload: union_InternalAttr {
                Id: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Multiple(payload: bool) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Multiple,
            payload: union_InternalAttr {
                Multiple: payload,
            }
        }
    }

    pub fn Name(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Name,
            payload: union_InternalAttr {
                Name: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn OnEvent(payload: InternalAttr_OnEvent) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::OnEvent,
            payload: union_InternalAttr {
                OnEvent: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Placeholder(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Placeholder,
            payload: union_InternalAttr {
                Placeholder: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Readonly(payload: bool) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Readonly,
            payload: union_InternalAttr {
                Readonly: payload,
            }
        }
    }

    pub fn Required(payload: bool) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Required,
            payload: union_InternalAttr {
                Required: payload,
            }
        }
    }

    pub fn Selected(payload: bool) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Selected,
            payload: union_InternalAttr {
                Selected: payload,
            }
        }
    }

    pub fn Src(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Src,
            payload: union_InternalAttr {
                Src: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Style(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Style,
            payload: union_InternalAttr {
                Style: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Tabindex(payload: i32) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Tabindex,
            payload: union_InternalAttr {
                Tabindex: payload,
            }
        }
    }

    pub fn Title(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Title,
            payload: union_InternalAttr {
                Title: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Type(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Type,
            payload: union_InternalAttr {
                Type: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn Value(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalAttr::Value,
            payload: union_InternalAttr {
                Value: core::mem::ManuallyDrop::new(payload),
            }
        }
    }
}

impl Drop for InternalAttr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_InternalAttr::Alt => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Alt) },
            discriminant_InternalAttr::Attribute => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Attribute) },
            discriminant_InternalAttr::Autocomplete => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Autocomplete) },
            discriminant_InternalAttr::Checked => {}
            discriminant_InternalAttr::Class => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Class) },
            discriminant_InternalAttr::DataAttribute => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.DataAttribute) },
            discriminant_InternalAttr::Disabled => {}
            discriminant_InternalAttr::Hidden => {}
            discriminant_InternalAttr::Href => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Href) },
            discriminant_InternalAttr::Id => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Id) },
            discriminant_InternalAttr::Multiple => {}
            discriminant_InternalAttr::Name => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Name) },
            discriminant_InternalAttr::OnEvent => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.OnEvent) },
            discriminant_InternalAttr::Placeholder => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Placeholder) },
            discriminant_InternalAttr::Readonly => {}
            discriminant_InternalAttr::Required => {}
            discriminant_InternalAttr::Selected => {}
            discriminant_InternalAttr::Src => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Src) },
            discriminant_InternalAttr::Style => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Style) },
            discriminant_InternalAttr::Tabindex => {}
            discriminant_InternalAttr::Title => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Title) },
            discriminant_InternalAttr::Type => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Type) },
            discriminant_InternalAttr::Value => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.Value) },
        }
    }
}

impl roc_std::RocRefcounted for InternalAttr {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Debug, )]
#[repr(C)]
pub struct R1 {
    pub attrs: roc_std::RocList<InternalAttr>,
    pub children: roc_std::RocList<InternalHtml>,
    pub tag: roc_std::RocStr,
}

impl roc_std::RocRefcounted for R1 {
    fn inc(&mut self) {
         self.attrs.inc();
     self.children.inc();
     self.tag.inc();

    }
    fn dec(&mut self) {
         self.attrs.dec();
     self.children.dec();
     self.tag.dec();

    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Debug, )]
#[repr(transparent)]
pub struct InternalHtml_Element {
    pub f0: R1,
}

impl roc_std::RocRefcounted for InternalHtml_Element {
    fn inc(&mut self) {
         self.f0.inc();

    }
    fn dec(&mut self) {
         self.f0.dec();

    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(transparent)]
pub struct InternalHtml_Text {
    pub f0: roc_std::RocStr,
}

impl roc_std::RocRefcounted for InternalHtml_Text {
    fn inc(&mut self) {
         self.f0.inc();

    }
    fn dec(&mut self) {
         self.f0.dec();

    }
    fn is_refcounted() -> bool {
        true
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_InternalHtml {
    Element = 0,
    Text = 1,
}

impl core::fmt::Debug for discriminant_InternalHtml {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Element => f.write_str("discriminant_InternalHtml::Element"),
            Self::Text => f.write_str("discriminant_InternalHtml::Text"),
        }
    }
}

roc_refcounted_noop_impl!(discriminant_InternalHtml);

#[repr(transparent)]
pub struct InternalHtml(*mut union_InternalHtml);

const _SIZE_CHECK_InternalHtml: () = assert!(core::mem::size_of::<InternalHtml>() == 4);
const _ALIGN_CHECK_InternalHtml: () = assert!(core::mem::align_of::<InternalHtml>() == 4);

impl InternalHtml {
    pub fn discriminant(&self) -> discriminant_InternalHtml {
        let discriminants = {
            use discriminant_InternalHtml::*;

            [ Element, Text ]
        };

        if self.0.is_null() {
            unreachable!("this pointer cannot be NULL")
        } else  {
            match std::mem::size_of::<usize>() {
                4 => discriminants[self.0 as usize & 0b011],
                8 => discriminants[self.0 as usize & 0b111],
                _ => unreachable!(),
            }
        }
    }

    fn unmasked_pointer(&self) -> *mut union_InternalHtml {
        debug_assert!(!self.0.is_null());

        let mask = match std::mem::size_of::<usize>() {
            4 => !0b011usize,
            8 => !0b111usize,
            _ => unreachable!(),
        };

        ((self.0 as usize) & mask) as *mut union_InternalHtml
    }

    unsafe fn ptr_read_union(&self) -> core::mem::ManuallyDrop<union_InternalHtml> {
        let ptr = self.unmasked_pointer();

        core::mem::ManuallyDrop::new(unsafe { std::ptr::read(ptr) })
    }

        pub fn is_Element(&self) -> bool {
        matches!(self.discriminant(), discriminant_InternalHtml::Element)
    }

    pub fn Element(f0: R1) -> Self {
        let tag_id = discriminant_InternalHtml::Element;

        let payload = InternalHtml_Element { f0 } ;

        let union_payload = union_InternalHtml { Element: core::mem::ManuallyDrop::new(payload) };

        let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(union_payload)) };

        Self((ptr as usize | tag_id as usize) as *mut _)
    }

    pub fn get_Element_f0(&self) -> &R1 {
        debug_assert!(self.is_Element());

        // extern "C" {
        //     fn foobar(tag_id: u16, field_index: usize) -> usize;
        // }

        // let offset = unsafe { foobar(0) };
        let offset = 0;
        unsafe { &*self.unmasked_pointer().add(offset).cast() }
    }


    pub fn get_Element(mut self) -> InternalHtml_Element {
        debug_assert!(self.is_Element());

        unsafe { core::mem::ManuallyDrop::take(&mut self.ptr_read_union().Element) }
    }

    pub fn is_Text(&self) -> bool {
        matches!(self.discriminant(), discriminant_InternalHtml::Text)
    }

    pub fn Text(f0: roc_std::RocStr) -> Self {
        let tag_id = discriminant_InternalHtml::Text;

        let payload = InternalHtml_Text { f0 } ;

        let union_payload = union_InternalHtml { Text: core::mem::ManuallyDrop::new(payload) };

        let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(union_payload)) };

        Self((ptr as usize | tag_id as usize) as *mut _)
    }

    pub fn get_Text_f0(&self) -> &roc_std::RocStr {
        debug_assert!(self.is_Text());

        // extern "C" {
        //     fn foobar(tag_id: u16, field_index: usize) -> usize;
        // }

        // let offset = unsafe { foobar(0) };
        let offset = 0;
        unsafe { &*self.unmasked_pointer().add(offset).cast() }
    }


    pub fn get_Text(mut self) -> InternalHtml_Text {
        debug_assert!(self.is_Text());

        unsafe { core::mem::ManuallyDrop::take(&mut self.ptr_read_union().Text) }
    }
}

impl Clone for InternalHtml {
    fn clone(&self) -> Self {
        use discriminant_InternalHtml::*;

        let discriminant = self.discriminant();

        match discriminant {
                    Element => {
                let tag_id = discriminant_InternalHtml::Element;

                let payload_union = unsafe { self.ptr_read_union() };
                let payload = union_InternalHtml {
                    Element: unsafe { payload_union.Element.clone() },
                };

                let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(payload)) };

                Self((ptr as usize | tag_id as usize) as *mut _)
            },
            Text => {
                let tag_id = discriminant_InternalHtml::Text;

                let payload_union = unsafe { self.ptr_read_union() };
                let payload = union_InternalHtml {
                    Text: unsafe { payload_union.Text.clone() },
                };

                let ptr = unsafe { roc_std::RocBox::leak(roc_std::RocBox::new(payload)) };

                Self((ptr as usize | tag_id as usize) as *mut _)
            },
        }
    }
}








impl core::fmt::Debug for InternalHtml {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_InternalHtml::*;

        match self.discriminant() {
                        Element => {
                let payload_union = unsafe { self.ptr_read_union() };

                unsafe {
                    f.debug_tuple("InternalHtml::Element").field(&payload_union.Element.f0).finish()
                }
            },
            Text => {
                let payload_union = unsafe { self.ptr_read_union() };

                unsafe {
                    f.debug_tuple("InternalHtml::Text").field(&payload_union.Text.f0).finish()
                }
            },
        }
    }
}


#[repr(C)]
union union_InternalHtml {    Element: core::mem::ManuallyDrop<InternalHtml_Element>,
    Text: core::mem::ManuallyDrop<InternalHtml_Text>,
}

impl roc_std::RocRefcounted for InternalHtml {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}


impl roc_std::RocRefcounted for union_InternalHtml {
    fn inc(&mut self) {
        unimplemented!();
    }
    fn dec(&mut self) {
        unimplemented!();
    }
    fn is_refcounted() -> bool {
        true
    }
}



pub fn frontend_init_for_host(arg0: u32) -> u32 {
    extern "C" {
        fn roc__frontend_init_for_host_1_exposed_generic(_: *mut u32, _: u32);
    }

    let mut ret = core::mem::MaybeUninit::uninit();

    unsafe {
        roc__frontend_init_for_host_1_exposed_generic(ret.as_mut_ptr(), arg0);

        ret.assume_init()
    }
}

pub fn frontend_view_for_host(arg0: u32) -> InternalHtml {
    extern "C" {
        fn roc__frontend_view_for_host_1_exposed_generic(_: *mut InternalHtml, _: u32);
    }

    let mut ret = core::mem::MaybeUninit::uninit();

    unsafe {
        roc__frontend_view_for_host_1_exposed_generic(ret.as_mut_ptr(), arg0);

        ret.assume_init()
    }
}